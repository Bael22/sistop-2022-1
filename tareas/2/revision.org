* Revisi√≥n de la tarea #2

  [[./README.md][Leer el planteamiento]]

** El profesor y los estudiantes

*** Ricardo Carrillo
 - Documentaci√≥n :: [[./CarrilloRicardo/README_tarea2.txt][README_tarea2.txt]]
 - Archivos :: [[./CarrilloRicardo/tarea2.py][tarea2.py]]
 - Comentarios ::
   - ¬°Muy buena presentaci√≥n! Se agradece encontrar un programa con
     ejecuci√≥n bonita y f√°cil de entender üòâ
   - Algunos alumnos (¬øs√≥lo al inicio de la ejecuci√≥n?) se duermen y
     nadie los vuelve a despertar ‚òπ
     [[./rev_img/cinco_dormiditos.png]]
     Una vez que el profesor atendi√≥ a los alumnos despiertos,
     puedes ver que /nadie despierta/ a 5, 6, 7.
     [[./rev_img/no_se_despiertan.png]]
     - (¬°ojo!  El alumno 8 entr√≥ cuando el 4 iba saliendo, y de /puro
      churro/ consigui√≥ que lo atendieran de inmediato ‚ò∫ ¬°Y eso es
      correcto!)
   - Cuando uno de tus =alumno()= se duerme, termina y√©ndose. Tal vez
     podr√≠a formarse en una cola, tomando un sem√°foro
     =alumno_dormido=; el =profesor()= lo despertar√≠a despu√©s.
   - Me qued√© un rato rasc√°ndome la cabeza para comenzar por qu√© la
     barrera del profesor es de a veces tres, a veces cinco alumnos
     - Me parece que es por el del =time.sleep(5)= inicial, seguido de
       =time.sleep(random.random())= en las otras vueltas, y la
       frecuencia de llegada de alumnos.
     - ¬°Ojo! El planteamiento dec√≠a que /los alumnos pueden tocar la
       puerta en cualquier momento/, no indica que tienen que pasar en
       un m√≠nimo de 3 en 3. Pero lo considero un /refinamiento/ üòâ
       (adem√°s, ¬°lo documentas como definici√≥n propia! ¬°Bien!)
   - C√≥digo claro, simple de leer.
     - Como √∫nica sugerencia, te recomendar√≠a separar las secuencias
       de color, no meterlas en cada uno de los =print()=. Algo como:
       #+begin_src python
	 colores = { 'amarillo': '\033[;33m',
		     'violeta': '"\033[;35m',
		     'verde': '\033[;32m',
		     'rojo': '\033[;31m',
		     'blanco': '\033[;37m',
		     'cyan': '\033[;36m' }
	 # (...)
	 print(f'{colores["blanco"]}ATENDIENDO SU DUDA # {colores["rojo"]}{duda} {colores["blanco"]}ALUMNO {colores["cyan"]}{a}')
       #+end_src
       Puede no parecer mucho ahorro (en n√∫mero de caracteres no lo
       es), pero hace mucho m√°s legible, depurable y extendible tu c√≥digo.
 - Calificaci√≥n :: 10

*** Iv√°n Hernandez
 - Documentaci√≥n :: /No entregada/
 - Archivos :: [[./HernandezIvan/alum_ase.py][alum_ase.py]]
 - Comentarios ::
   - No hay documentaci√≥n ‚òπ S√≥lo un breve comentario al inicio del
     programa
     - Me dejas a m√≠ la chamba de identificar los patrones de
       sincronizaci√≥n que utilizaste. ¬°Pero es parte importante del
       objetivo de la tarea.
     - No s√≥lo es resolverla pasando mensajes a ver c√≥mo funciona,
       sino identificar qu√© construcciones y qu√© l√≥gica empleas.
   - Acceso concurrente no sincronizado: Proteges a =cuenta= con
     =mutex= en =alumnos()=, pero no en =asesor()=. ¬øEst√°s seguro de
     que no hay posibilidad de condici√≥n de carrera?
   - Cada alumno pide una √∫nica asesor√≠a, no son varias
     preguntas. Este punto es importante, porque permitir√≠a observar
     el cambio de atenci√≥n entre varios alumnos que est√©n dentro del
     cub√≠culo
   - No implementas capacidad m√°xima del cub√≠culo (la primera regla
     que se te pide implementar)
   - El programa siempre termina en error, porque no existe =descansa=
     (hay que reemplazar =descansa.asesor.acquire()= por
     =descansa_asesor.acquire()=)
     - S√≠, es un mero dedazo...
   - El asesor no est√° esperando a tener cero alumnos frente a s√≠ para
     echarse una siesta, sino a haber procesado a los nueve alumnos
     que desde un principio sab√≠a que iban a llegar. ¬°Pero el asesor
     no tiene /por qu√© saber/ cu√°ntos alumnos vendr√°n!

 - Calificaci√≥n :: 6

*** Santiago Diego y Armando Ugalde
 - Documentaci√≥n :: [[./SantiagoDiego-UgaldeArmando/README.md][README.md]]
 - Archivos :: [[./SantiagoDiego-UgaldeArmando/los_alumnos_y_el_asesor.py][los_alumnos_y_el_asesor.py]]
 - Comentarios ::
   - ¬°Muy bueno que encontraran similtud con otros problemas
     abordados! En efecto, es un /productores/consumidores/ con
     restricciones adicionales
     - Si quieren leer m√°s respecto a este problema, busquen al
       /barbero dormil√≥n/ (/sleeping barber/).
   - Me parece curioso que hayan utilizado =eid_lock =
     threading.Lock()= y, en la siguiente l√≠nea, =mutex =
     threading.Semaphore(1)=.
     - ¬°Es absolutamente v√°lido!
     - Pero estil√≠sticamente, no lo entiendo. Un =Lock()= es
       exactamente igual que un mutex hecho con un =Semaphore(1)=.
   - Muy bueno el uso de =queue.Queue()=, y muy bueno que viniera de
     algo que yo no hab√≠a ense√±ado expresamente.
   - Cuando v√≠ que defin√≠an una =class Estudiante=, cre√≠ que hab√≠an
     implementado un monitor. ¬°Habr√≠a estado muy bonito meter toda la
     l√≥gica de sincronizaci√≥n dentro de cada =Estudiante=!
   - Me parece que lo que observan relativo al =profe_consumidor()= y
     la necesidad de agregarle un =time.sleep(1.5)= es correcto
     - El profesor es muy /ansioso/ y no se duerme cuando no tiene
       nada que hacer (¬°que es una de las reglas del planteamiento! ‚òπ)
     - Podr√≠an resolver la necesidad del =sleep= poniendo al profesor
       a dormir con un sem√°foro.
     - Con un patr√≥n similar (aunque parcial) al del apagador: Que los
       alumnos verificaran cu√°ntos alumnos hay al entrar al cub√≠culo,
       y si no hab√≠a ninguno m√°s, que /prendan la luz/ para que el
       profesor se despierte.
 - Calificaci√≥n :: 9

*** Alan S√°nchez
 - Documentaci√≥n :: [[./S√°nchezAlan/Tarea2_SCA.pdf][Tarea2_SCA.pdf]]
 - Archivos :: [[./S√°nchezAlan/Tarea2.py][Tarea2.py]]
 - Comentarios ::
   - L√°stima que no pudiste terminar la implementaci√≥n... ¬°Pero qu√©
     bueno que la enviaste!
   - Comentas que no supiste c√≥mo hacer que cada tanto llegaran
     alumnos. Tu programa tiene un √∫nico alumno implementado: Hay un
     √∫nico =threading.Thread(target=alumnos, args =[]).start()=
     - Pero tu alumno tiene dudas infinitas: Dentro de un =while
       True:= √∫nicamente espera un momento, pregunta tres veces, y
       vuelve a repetir
     - yo te sugerir√≠a cambiar a tu alumno por:
       #+begin_src python
	 def alumnos():
	     global alumno
	     for i in range(3):
		 print('   A: Tengo dudas')
		 alumno.release()

	 # (...)
	 while True:
	     threading.Thread(target=alumnos, args=[]).start()
	     time.sleep(random.random() / 3.0)
       #+end_src
     - Muy similar al c√≥digo que tienes, pero con esto ya ser√≠an
       alumnos diferentes (hilos concurrentes, no un alumno que vuelve
       y vuelve y vuelve y vuelve a preguntar)
   - El mutex =profeOcupado= es innecesario, porque s√≥lo tienes un
     profesor, no hay acceso concurrente.
   - La raz√≥n por la que el profesor se queda /atorado/ es porque no
     controlaste bien la l√≥gica sobre =numIn=: Despu√©s de haber
     atendido a seis alumnos, =numIn = 6=, y nunca entra a la
     condicional que llamar√≠a a =profesor()=
     - (¬øo ser√° que tendr√≠as que decrementar =numIn= al terminar la
       atenci√≥n de un alumno? Bueno, la implementaci√≥n es cosa tuya)
     - Si eliminamos tu l√≠nea 36, el flujo /me parece/ que funciona
       correctamente.
     - ¬°Felicidades! Tu programa s√≠ funciona, s√≥lo le falt√≥ ese
       detalle
 - Calificaci√≥n :: 6

** Santa Claus

*** Raul Cruz
  - Documentaci√≥n :: [[./CruzRaul/DetallesDeLaEntrega.txt][DetallesDeLaEntrega.txt]]
  - Archivos :: [[./CruzRaul/santa_claus.py][santa_claus.py]]
  - Comentarios ::
    - Me gusta tu implementaci√≥n de probabilidad revisando el /tipo/
      de =fallo= ‚ò∫
    - ¬°Funciona bien! ¬°Buen√≠simo! Peroooo... Veo una ligera /trampita
      l√≥gica/
    - Santa es √∫nicamente un sem√°foro dormil√≥n (me parece que el
      =time.sleep(10)= sale sobrando)... ¬øser√° que los renos existen,
      pero Santa es efectivamente s√≥lo un mito? ‚òπ
      - Los renos /personifican/ a Santa; el reno n√∫mero 9 en llegar
        es el que dice /Entregamos los regalos/
      - El reno tendr√≠a que despertar a Santa, con un
        =santa_despierto.release()=
      - Mismo comentario respecto a los elfos: La funci√≥n
        =impresion()= contiene pedazos de l√≥gica que deben pertenecer
        a =elfos()= y pedazos que deben pertenecer a =santa()
      - Y eso obligar√≠a a que =santa()= tuviera que implementarse con
        un poquito m√°s de l√≥gica:
	#+begin_src python

	  def santa():
	      while True:
		  # santa se duerme
		  santa_despierto.acquire()
		  mut_renos.acquire()
		  if c_renos == 9:
		      print('Entregamos los regalos Jo, jo, jo')
		      #(...)
		  mut_renos.release()
		  mut_elfos.acquire()
		  if num_elfos_con_broncas > 1: # Me la saqu√© de la manga
		      print('Ayudando a los elfos')
		      #(...)
		  mut_elfos.release()
		  print('Santa est√° dormido zzzz')
		  time.sleep(10)
        #+end_src
  - Calificaci√≥n :: 8

*** Alberto Garc√≠a Figueroa y Cristobal Garc√≠a
  - Documentaci√≥n :: [[./GarciaFigueroAlberto-GarciaCristobal/README.md][README.md]]
  - Archivos :: [[./GarciaFigueroAlberto-GarciaCristobal/SantaProblem.py][SantaProblem.py]]
  - Comentarios ::
    - Muy buena soluci√≥n ‚Äì limpia y f√°cil de entender
    - Me gust√≥ que separen todas las funciones que mandan mensajes,
      pues la l√≥gica de cada una de las funciones de ‚Äùtrabajo real‚Äù
      queda m√°s clara
    - me queda la duda ‚Äî El programa no tiene previsto terminar
      /jam√°s/ (¬øalguna vez terminar√° la navidad?), as√≠ que... ¬øPor qu√©
      hacen =join()= sobre todos los hilos? (¬øpara mantener al hilo
      iniciador vivo tal vez?)
  - Calificaci√≥n :: 10

*** Rodrigo Jim√©nez
 - Documentaci√≥n :: [[./JimenezRodrigo/REEDME.txt][REEDME.txt]]
 - Archivos :: [[./JimenezRodrigo/santa.py][santa.py]]
 - Comentarios ::
   - Le agregaste complejidad al problema, con tu planteamiento de
     =mam√°_Claus= para ayudar con el exceso de
     solicitudes. ¬°Buen√≠simo!
     - Hay un detalle con tu implementaci√≥n: La mam√° no corre de forma
       aut√≥noma: Al inicio de tu ejecuci√≥n aparece siempre una
       excepci√≥n:
       #+begin_src text
	 $ python3 JimenezRodrigo/santa.py 
	 Exception in thread Thread-2:
	 Traceback (most recent call last):
	   File "/usr/lib/python3.9/threading.py", line 973, in _bootstrap_inner
	     self.run()
	   File "/usr/lib/python3.9/threading.py", line 910, in run
	     self._target(*self._args, **self._kwargs)
	 TypeError: mam√°_Claus() missing 1 required positional argument: 'elfos_espera'
       #+end_src
       Porque intentaste lanzar a =mam√°_Claus()= como un hilo sin
       argumentos, y requiere un par√°metro.
     - =mam√°_claus()= no tiene una l√≥gica multihilos como los dem√°s
       actores, s√≥lo atiende a los elfos que est√©n pendientes.
     - Se nota que /intentaste/ hacer a la mam√° tambi√©n concurrente
       (por el =d_mam√°.release()=, aunque no hay ning√∫n
       =d_mam√°.acquire()=).
   - Tienes raz√≥n en tu comentario, hay que rascarse un poco la cabeza
     para encontrar por d√≥nde sigue el flujo de control ‚ò∫
     - Pero est√° bien ‚Äî modificaste el problema agreg√°ndole un poco de
       complejidad a cambio.
     - Me habr√≠a gustado m√°s que =mam√°_Claus()= fuera /verdaderamente/
       un hilo, no una funci√≥n ayudante llamada expl√≠citamente por
       =elfo()=.
     - Mejor a√∫n: Ser√≠a bueno que los elfos no tuvieran que elegir
       qui√©n les ayuda (¬°ah√≠ suena a una peligrosa oportunidad para
       condiciones de carrera!), sino que simplemente hicieran un
       =puerta_claus.acquire()=, y que la se√±al la atendiera =santa()=
       o =mam√°_Claus()= seg√∫n conviniera...
 - Calificaci√≥n :: 10

*** Jorge Manzanares y Jesus Salazar
 - Documentaci√≥n :: [[./ManzanaresJorge-SalazarJesus/SantaClausDoc.txt][SantaClausDoc.txt]]
 - Archivos :: [[./ManzanaresJorge-SalazarJesus/santaClaus.py][santaClaus.py]]
 - Comentarios ::
   - El sistema funciona... Pero... =Santa()=, que es tan dormil√≥n,
     ¬°no puede dormir jam√°s!
     - Lo programaste con una horrible, horrible, horrible espera
       activa:
       #+begin_src python
	 def Santa():
	     global duendes_tristes, renos_puntuales
	     while True:
		 while(duendes_tristes < 3 and renos_puntuales < 9):
		     pass
       #+end_src
     - Eso lleva el uso de CPU al 100%, en el ciclo cerrado =while= /
       =pass=
     - Se soluciona muy f√°cil: Deber√≠as haber puesto un
       =santa_despierto.acquire()= (con =santa_despierto=Semaphore(0)=
       en la inicializaci√≥n)
     - Y tanto =Duende()= como =Reno()= tendr√≠an que hacer un
       =santa_despierto.release()= despu√©s de agregarse a su lista ‚Äî y
       verificar que fueran suficientes (no corresponde a Santa
       determinar si son 3 y 9... los otros deben dejarlo dormir, y
       autoorganizarse)
   - Otro punto importante: Tanto en =Duende()= como en =Reno()=
     proteges a las variables compartidas de acceso concurrente con un
     mutex. Pero ese mutex debe tambi√©n ser utilizado en =Santa()=
     para la comparaci√≥n y reasignaci√≥n de =duendes_tristes=,
     =lista_duendes_tristes= y =renos_puntuales=.
 - Calificaci√≥n :: 7

*** I√±aky Ordiales
 - Documentaci√≥n :: [[./OrdialesI√±aky/InfoSolucion.txt][InfoSolucion.txt]]
 - Archivos :: [[./OrdialesI√±aky/hiloSanta.c][hiloSanta.c]]
 - Comentarios ::
   - ¬°Bien! Un bonito reto. ¬°Resolviste con variables de condici√≥n! (y
     barreras, y dem√°s cosas m√°s cercanas a lo que vimos...)
   - Adem√°s te saliste de lo facilito,y lo hiciste en C. ¬°Buen√≠simo! :-D
     - Y programas cuidadosamente, a la defensiva, correctamente
       verificando la creaci√≥n de cada uno de los hilos. ¬°Qu√© gusto
       leer as√≠!
   - A nivel estilo: Te sugiero no hacer los comentarios /despu√©s/ del
     c√≥digo a que te refieres, sino que /arriba/ de √©ste. Aunque sea
     una s√≥la l√≠nea, poner los comentarios como lo haces lleva a
     c√≥digo demasiado /ancho/.
   - No hab√≠a visto la soluci√≥n que propones, de crear al ‚Äùpaso del
     tiempo‚Äù como un hilo expreso.
     - ¬øDe cu√°ndo ac√° el paso del tiempo espera a que ocurra
       determinado evento? ¬°ah, s√≠! Los renos son m√°gicos, lo
       olvidaba. ¬°Se vale! üòâ
   - /Me parece/ que tendr√≠as que proteger con un mutex a
     =esperaReno=, que decrementas y comparas en tus l√≠neas 121,
     123, 134.
   - Llama a mi atenci√≥n que en =elfo()= implementes una barrera
     artesanalmente, en vez de usar una =pthread_barrier= como lo
     hiciste con =reno()=.
   - ¬°Muy buena implementaci√≥n!
     - ¬øMe pides una implementaci√≥n /m√°s limpia/? Bueno, puedes ver
       las que he calificado mejor de entre las de tus
       compa√±eros. Pero las soluciones son m√°s /tradicionales/,
       acotadas a lo que vimos en clase.
 - Calificaci√≥n :: 10

*** Carlos Mendoza
 - Documentaci√≥n :: [[./MendozaCarlos/Descripcion_Tarea2.txt][Descripcion_Tarea2.txt]]
 - Archivos :: [[./MendozaCarlos/Santa_Claus_Tarea2.py][Santa_Claus_Tarea2.py]]
 - Comentarios ::
   - Tus =renos()= y =elfos()= son eternos, viven dentro de un =while
     True=. Pero... ¬øY =santa()=? ¬°S√≥lo dice una vez que se va a
     dormir y se muere! ¬°Has matado al esp√≠ritu de la navidad! ‚òπ
   - Fuera de ese punto... tu implementaci√≥n es casi id√©ntica a la de
     Miguel Villanueva
     - ¬°No hay problema! yo les dije que pod√≠an trabajar en equipos de
       dos personas
     - Revisa los comentarios que hago a su entrega, aplican tambi√©n a
       la tuya.
 - Calificaci√≥n :: 6

*** Miguel Villanueva
 - Documentaci√≥n :: [[./VillanuevaMiguel/DetallesTarea2.txt][DetallesTarea2.txt]]
 - Archivos :: [[./VillanuevaMiguel/santa.py][santa.py]]
 - Comentarios ::
   - ¬°Ojo con la ortograf√≠a, incluso en programitas tan chiquitos como
     √©ste!
     - No es /¬´A regresado el reno¬ª/, sino /¬´Ha regresado el reno¬ª/
   - En =santa()=, no hace falta adquirir un mutex (tanto =muRenos=
     como =muElfos=) para liberar una se√±al (=vacaciones.release()= o
     =elfoProblemas.release()=: Estas son operaciones verdaderamente
     at√≥micas. Usa los mutexes √∫nicamente para controlar acceso a
     datos.
   - Tienes un /Santa hiperactivo/: ¬°Nunca se detiene a descansar!
     Vive en un ciclo eterno de mandar se√±ales liberando a los renos y
     elfos. Me parece que equivocaste el sentido de algunas de las
     se√±ales.
     - =elfoProblemas= deber√≠a enviarse (=release()=) por =elfo()= y
       recibirse por =santa()=
     - Misma cosa para =vacaciones= en =renos()=
   - En resumen... El programa va por el camino correcto, pero en
     realidad no est√° haciendo la sincronizaci√≥n que requerimos
     - S√≥lo lo que te dan las =Barrier=
 - Calificaci√≥n :: 6


** Gatos y ratones

*** Bryan D√≠az
 - Documentaci√≥n :: [[./D√≠azBryan/Ejercicio_Ratones_Gatos.txt][Ejercicio_Ratones_Gatos.txt]]
 - Archivos :: [[./D√≠azBryan/Gatos_Ratones.py][Gatos_Ratones.py]]
 - Comentarios ::
   - Detalle que simplemente me llam√≥ la atenci√≥n üòâ ¬øA poco en tu
     lenguaje diario dir√≠as /Inserta la cantidad de
     (gatos|ratones|platos)/? A veces usamos f√≥rmulas que vimos en
     alg√∫n lugar... pero no coresponden al lenguaje /natural/. ¬°Busca
     que los programas que desarrolles se comuniquen con su usuario
     como lo har√≠as t√∫!
   - Planteas un punto importante: ¬øC√≥mo matar a los hilos de los
     ratones muertos?
     - Se me ocurre que podr√≠as tener un arreglo =estados_r= donde
       representes el estado de cada rat√≥n. Este arreglo est√°
       inicializado con todos los valores a =1= (o =True=, como sea).
     - Cuando un =gato()= se come a un =raton()=, actualiza su valor a
       =0= (o =False=).
     - Al inicio del cuerpo del =while=, cada =raton()= verifica si su
       estado es falso. De ser as√≠, termina su ejecuci√≥n (=return=).
     - Hay m√°s estrategias... sigue leyendo la respuesta a N√©stor y Est√©ban.
   - Tienes raz√≥n, el tiempo que le toma comer a cada uno de los
     animales es muy cortito. Tal vez por eso tuve que buscar con lupa
     para encontrar mensajes de =se lo comieron= o =no se acerca por
     ser un caballero=...
   - ¬°Buena implementaci√≥n!
 - Calificaci√≥n :: 10

*** N√©stor Fuerte y Est√©ban Tafolla
 - Documentaci√≥n :: [[./FuerteNestorTafollaEsteban/Tarea2.txt][Tarea2.txt]]
 - Archivos :: [[./FuerteNestorTafollaEsteban/PruebaDeHilos.py][PruebaDeHilos.py]]
 - Comentarios ::
   - Se quedaron con una duda muy similar a la de su compa√±ero Bryan,
     que resolvi√≥ este mismo problema, aunque m√°s acotado (que el
     rat√≥n en cuesti√≥n /deje de comer/ al morirse)
     - La respuesta... No es sencilla. En Python, no se puede
       simplemente /matar/ a un hilo
       - Podr√≠a dejar un estado corrupto, y el resto del proceso
         avanzando, vivo, en memoria
     - Pueden crear hilos creando una clase que herede de =Thread= e
       implementar =stop()= como sugiere
       https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/
     - Pueden usar =threading.Event()= para configurar una /pastilla
       asesina/ (/pill to kill/):
       https://stackoverflow.com/questions/18018033/how-to-stop-a-looping-thread-in-python
   - Revis√© brevemente la implementaci√≥n. Me parece que hace todo lo
     solicitado, incluyendo el dejar comer a los ratones ‚Äùpor honor‚Äù y
     com√©rselos cuando es necesario.
   - Me llama la atenci√≥n el /abuso de mutexes/ que hacen, por
     ejemplo:
     #+begin_src python
       gatos.acquire()
       gatos_en_plato -= 1
       gatos.release()
       ratones.acquire()
       raton_en_plato -=1
       ratones.release()
       ratones.acquire()
       ratones_numero-=1
       ratones.release()
     #+end_src
     No tiene mucho sentido entregar y, de inmediato, readquirir
     =ratones=. Podr√≠as hacer los dos decrementos (operaciones muy
     baratas/sencillas) /sosteniendo/ el mutex, y evitar dos llamadas
     al sistema.
 - Calificaci√≥n ::  10

** El cruce del r√≠o
*** Eduardo Moreno
 - Documentaci√≥n :: [[./MorenoEduardo/readme.md][readme.md]]
 - Archivos :: [[./MorenoEduardo/Tarea2.py][Tarea2.py]]
 - Comentarios ::
   - ¬°Bien solucionado!
   - Respecto a tus dudas, s√≠, not√© tambi√©n que hay que ‚Äùmatarlo‚Äù dos
     veces para recuperar el control. No te puedo dar una respuesta
     r√°pida de por qu√© esto ocurre
     - Puede ser que... tu =exit()= haga que se detenga el hilo
       principal, pero Python mantiene vivo el programa hasta que
       salgan los dem√°s hilos
     - Ya con el segundo ‚ÄùCtrl-C‚Äù mata tambi√©n a los hilos activos. Si
       le agrego un =print(threading.enumerate())= justo antes del
       =sys.exit()=:
       #+begin_src text
	 ==== Momento de irnos ====
	 ^C‚ïë‚ïë Ya terminamos de pasar a todos ‚ïë‚ïë
	 [<_MainThread(MainThread, started 140432593831744)>, <Thread(Thread-5, started 140432587900480)>, <Thread(Thread-6, started 140432579507776)>, <Thread(Thread-7, started 140432571115072)>]
	 ^CException ignored in: <module 'threading' from '/usr/lib/python3.9/threading.py'>
	 Traceback (most recent call last):
	   File "/usr/lib/python3.9/threading.py", line 1448, in _shutdown
	     lock.acquire()
	 KeyboardInterrupt: 
       #+end_src
     - Supongo que se /porta/ diferente en Windows porque el manejo de
       senales es diferente
     - ¬°Me parece curioso lo que mencionas respecto al uso de
       =random()= en Windows! Me encantar√≠a ver a qu√© te refieres...
 - Calificaci√≥n :: 10

** El elevador

*** Erick Vazquez
 - Documentaci√≥n :: [[./VazquezErick/Tarea2_VazquezErick.pdf][Tarea2_VazquezErick.pdf]]
 - Archivos :: [[./VazquezErick/elevador.py][elevador.py]]
 - Comentarios ::
   - Me gusta tu implementaci√≥n, es ingeniosa y distinta de lo que
     acostumbro ver
   - Ante tus preguntas:
     - Me parece que tienes raz√≥n con la duda de las l√≠neas 57
       y 63. No puedo asegurarlo al 100%, pero me parece que tienes
       raz√≥n ‚ò∫
     - Respecto a tu pregunta relacionada con el =pop=, ya que tienes
       todo tan avanzado en ese sentido, tal vez convendr√≠a almacenar
       a los =Usuarios= en un diccionario y no en una lista. De este
       modo, en vez de sacar a uno de los =Usuarios= (que tal vez no
       quiere ir al piso donde lo estas dejando), sacas al =Usuario=
       que corresponda por su nombre.
     - Muy buen trabajo, incluyendo el refinamiento propuesto.
 - Calificaci√≥n :: 10
